//namespace: test

/******************************************************************************\
FILE:           task.zm
AUTHOR:         Chris van Run (UiL-OTS)
ADAPTED BY:     -

EXPERIMENT:     Repeat sequence task

DESCRIPTION: This is the actual task block.

HISTORY:
2014-05-15 CvR   Created.

\******************************************************************************/
//import test_page;

Block pretest
{
    bool passed = false;        // If true, the participant passed the pretest.
    int  number_pretest = 0;    // Counts the number of pretest runs.

    Block pretest_task
    {
        int correct;

        on_event:entry()
        {
            correct = 0;
            number_pretest++;

            num_cycles = TESTITEMS.size;		
            // Prepare test page: no feedback, no progress bar, and prompt disabled.
            test_page.setup(num_cycles, true, true, PRE_TEST_OVERLAY_TEXT);
        }

        on_event:exit()
        {
            if(correct >= NUMBER_OF_MINIMUM_CORRECT_PRETEST)
                passed = true;

            pretest_save();
        }

        Trial trial
        {
            on_event:entry()
            {
                 TestItem item = TESTITEMS[pretest_task.cycle];
                 test_page.action(this,
                                  item,
                                  reference_time,
                                  pretest_task.cycle,
                                  "beep.wav"
                                  );
            }

            on_event:exit()
            {
                if (test_page.response.correct != 1)
                    pretest_task.correct = 0;
                else
                    pretest_task.correct++;

                if (NUMBER_OF_MINIMUM_CORRECT_PRETEST > 0 &&
                    pretest_task.correct >= NUMBER_OF_MINIMUM_CORRECT_PRETEST)
                {
                    pretest_task.num_cycles = pretest_task.cycle;
                }

                TestOutput output;
                output.trial = TRIAL_NR;
                output.block = number_pretest;
                
                output.sequence = test_page.item.tokens;
                output.response = test_page.response.value;
                output.correct= test_page.response.correct;
                output.rt_complete = test_page.response.rt_complete;
                
                output.rt1 = test_page.response.rts[1];
                output.rt2 = test_page.response.rts[2];
                output.rt3 = test_page.response.rts[3];
                output.rt4 = test_page.response.rts[4];
                output.rt5 = test_page.response.rts[5];
                output.rt6 = test_page.response.rts[6];
                output.rt7 = test_page.response.rts[7];
                output.rt8 = test_page.response.rts[8];
                output.rt9 = test_page.response.rts[9];
                output.rt10 = test_page.response.rts[10];

                pretest_output_append(output);

                test_page.cleanup();
            }
        }
    }

    bool test_passed()
    {
        return passed;
    }

    int nth_pretest()
    {
        return number_pretest;
    }
}

void task_call(Part caller, dur t_response_dur, int number_pretest)
{
	// set global variables
	TESTITEMS = pretest_sequences;
	RESPONSE_DURATION = t_response_dur;

    // To keep track of the nth time we enter the pretest
    pretest.number_pretest = number_pretest;
	
    // Activate the task. When the task is done, the registered caller
    // (c.q. the main experiment object) will automatically be signalled.
    pretest.enter(caller);
}
