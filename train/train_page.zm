//namespace: instruct

/******************************************************************************\
FILE:           test_page.zm
AUTHOR:         Theo Veenker (UiL-OTS) <T.J.G.Veenker@uu.nl>
ADAPTED BY:     Chris van Run

DESCRIPTION:

Provides a page object to show to the participant during test phase trials.
It handles presenting the stimulus and recording the participant's response.


HISTORY:
2012-03-20 TV   Created.
2014-05-26 CvR	Adapated.

\******************************************************************************/

import std_sound_output_device;

Page train_page
{
    init()
    {
        fill_pattern_color = TEST_PAGE_COLOR;
    }

	on_event:message()
    {
        // Process button-box message. See setup() below.
       process_hit(message_arg, event_time);
       println(message_arg);
    }
    
    on_event:key_press()
    {
          // Handle left-shift (A) and right-shift (B).
        if (input_key == KEY_Shift_L)
        	process_hit(0, event_time);
        else if (input_key == KEY_Shift_R)
        	process_hit(1, event_time);
        else if (input_key == ' ')
        	println(control.target.object_name);
        else
			handle_special_key(this, input_key, input_modifiers);
    }


    VerticalLayout layout
    {
        init()
        {
            spacing = 50;
            height = 0;     // 0 means as large as possible
        }

		CanvasGadget canvas
		{	
			init()
			{
				fill_pattern_color = TEST_PAGE_COLOR;
                size = 800, 800;
                offset_x = width / 2;
                offset_y = height / 2;
			}
			
			TextShape ok
			{				
				init()
				{
					font_family = TEST_PAGE_STIMULUS_FONT_FAMILY;
                    font_size = TEST_PAGE_STIMULUS_FONT_SIZE;
                    line_pattern_color = TEST_PAGE_STIMULUS_TEXT_COLOR;
                    hor_alignment = ALIGN_CENTER;
                    ver_alignment = ALIGN_CENTER;
                    
					text = STIMULUS_TEXT; //"OK" or "REPEAT"
					
					is_visible = false;
				}
			}
			
			ImageShape sound_playing
			{   
				dur fade_in_dur;
				int num_frames_fade_in; 				
				pre_update()
				{
					if(relative_frame < num_frames_fade_in )
					{
						this.alpha = real(relative_frame)/real(num_frames_fade_in);
					}
				}
				
				init() //test_window1
				{	
                    width = 100;
                    height = 100;
					x = -width/2;
					y = -height/2;
                    image = stimuli_dir() + "audioicon.svg";
 
                    is_visible = false;
                    fade_in_dur = FADE_PERIODE_AUDIOICON;
					num_frames_fade_in = int(fade_in_dur/display_device.refresh_interval); 	
				}
			}
			
			CircleShape buttonA
			{
				color unpressed_line_pattern_color = color:black;
				color pressed_line_pattern_color = color:red;
				color unpressed_fill_pattern_color = color:slateblue;
				color pressed_fill_pattern_color = color:black;
				
				init()
				{
					x = -150; y = 200;
					radius = 30;
	 
					line_width = 3;
	 
					line_pattern_color =unpressed_line_pattern_color;
	 
					fill_pattern_color = unpressed_fill_pattern_color;
	 
					is_visible = true;
				}
				
				void pressed()
				{
					if(line_pattern_color == unpressed_line_pattern_color)
					{
						line_pattern_color = pressed_line_pattern_color;
						fill_pattern_color = pressed_fill_pattern_color;
					}
					else
					{
						line_pattern_color = unpressed_line_pattern_color;
						fill_pattern_color = unpressed_fill_pattern_color;
					}
				}
				
				Timer timer { expire() { pressed();}}
			}
				
			CircleShape buttonB
			{	
				color unpressed_line_pattern_color = color:black;
				color pressed_line_pattern_color = color:red;
				color unpressed_fill_pattern_color = color:darkorange; 
				color pressed_fill_pattern_color = color:black;
							
				init()
				{
					x = 150; y = 200;
					radius = 30;
	 
					line_width = 3;
	 
					line_pattern_color = unpressed_line_pattern_color;
	 
					fill_pattern_color = unpressed_fill_pattern_color;
	 
					is_visible = true;
				}
				
				void pressed()
				{
					if(line_pattern_color == unpressed_line_pattern_color)
					{
						line_pattern_color = pressed_line_pattern_color;
						fill_pattern_color = pressed_fill_pattern_color;
					}
					else
					{
						line_pattern_color = unpressed_line_pattern_color;
						fill_pattern_color = unpressed_fill_pattern_color;
					}
				}
				Timer timer { expire() { pressed();}}
			}
		}
		
        void reset()
        {
            full_abort();
			audio.abort();
        }
    }
    

	Timer instruct
	{
		string press_A;
		string press_B;
		string current;

		int times;
		bool comply;

		void reset()
		{
			instruct.abort();
			comply = true;
			times = 0;
		}

		init()
		{
			press_A = PRESS_A_INSTRUCTION;
			press_B = PRESS_B_INSTRUCTION;
			current = press_B;
			reset();
		}
		
		on_event:expire()
		{
			if(!comply)
				this.start(now()+DURATION_TO_COMPLETE_INSTRUCTION); //delay
			else
			{
				if(current == press_A)
					current = press_B;
				else
					current = press_A;
				test_page_overlay.show_prompt(current);

				times++;
				if(times < NUMBER_OF_TRAINING_LISTENINGS+1)
					this.start(now()+DURATION_TO_COMPLETE_INSTRUCTION);
				else
				{
					done(CONTINUE);
					times = 0;
				}
				comply = false;
			}
		}
	}
	
	SoundChain audio
	{
		SoundFile clip {}
		SoundPlayback playback {}

		void play(string token)// play the sound
		{
				audio.abort(); //stop any previous playing sounds
				audio.clip.file = stimuli_dir() + "sounds/" + token + ".wav"; // i.e. ./stimuli/sounds/A.wav
				audio.start();
				layout.canvas.sound_playing.start(audio.expected_start_time, audio.duration); //show visual queues
		}
	}	

    void process_hit(int val, time t)
    {
    	if(val == 0)
    	{
    		audio.play("A");
    		layout.canvas.buttonA.pressed();
            layout.canvas.buttonA.timer.start(t+PRAC_BUTTON_SHOW_PRESSED_DUR);
            if(instruct.current == instruct.press_A)
            	instruct.comply = true;
    	}
    	else if(val == 1)
    	{
    		audio.play("B");
    		layout.canvas.buttonB.pressed();
            layout.canvas.buttonB.timer.start(t+PRAC_BUTTON_SHOW_PRESSED_DUR);
            if(instruct.current == instruct.press_B)
            	instruct.comply = true;
    	}
     
    }


    // Aborts any ongoing activity on this page and signals the initiator
    // of the trial that we're done.
    void done(int msgid)
    {
        println("done!");
        // Just in case; abort presentation if still active
        layout.reset();
		
        signal_target(msgid);   // tell caller we're done
        target = null;
        
        control.target = null;
        control.button_box.disable_buttons();

        control.clear_status();
    }

    //==========================================================================

    // Performs preparatory work required before using this page.
    void setup(int ntrials=-1, bool fb=false, bool pr=false, string overlay_text = "")
    {
        test_page_overlay.setup(this);
        
        // Show or hide prompt.       
        test_page_overlay.show_prompt(pr ? 
             overlay_text : "");
             
        // Enable or disable the progress bar.
        test_page_overlay.show_progress_bar(ntrials);   // disabled if < 0

        // Enable or disable feedback.
        test_page_overlay.enable_feedback(fb);          // disabled if false
              
        //audio settings
        audio.playback.device = sound_output_device;
    }


    // Performs cleaning up if necessary.
    void cleanup()
    {
        test_page_overlay.cleanup();
        target = null;
        
        instruct.reset();
        control.button_box.disable_buttons();
        control.target = null;
    }


    // Starts a trial.
    void action(Object caller, time tref, int count=-1)
    {
        test_page_overlay.show_prompt(INSTRUCTION_PREAMBLE);
        
        // Show this page (if not yet done) and make tref the trial start time.
        tref = test_window1.show_test_page(this, tref + INTERTRIAL_INTERVAL);
        
          // Enable button-box buttons.       
        control.target = this;
        control.button_box.disable_buttons();
        control.button_box.enable_button(0, 0); // button 0 means A
        control.button_box.enable_button(2, 1); // button 1 means B

		//stimulus
        instruct.start(tref);
		
        // Response interval starts at stimulus offset + STIM_RESP_INTERVAL. 
        // Timeout after RESPONSE_DURATION unless this duration is 0s or less.

        // Update status line on control window. Cleared in done() above.
        control.set_status("training");


        // Remember who to signal when the trial is over.
        target = caller;
    }
}
