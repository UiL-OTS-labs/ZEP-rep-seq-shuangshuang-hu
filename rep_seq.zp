/******************************************************************************\
FILE:           req_seq.zp
AUTHOR:         Chris van Run (UiL-OTS) <C.P.A.vanRun@uu.nl>
ADAPTED BY:     -

EXPERIMENT:	Repeat sequence experiment

DESCRIPTION: Participant is presented with an audio sequence of 'A' or 'B' and
* has to press the corresponding buttons in the right order following the presentation.

HISTORY:
2014-06-10 CvR   Created.

\******************************************************************************/

requires 1.14;

import std_windows1;

import std_entry_page1;
import std_exit_page1;
import std_blank_page;

import test_page;
import pause_page;
import texts_en; // contained all the text elements.
import shuffle;
import output;

import listening::task;
import button::task;
import train::training;
import pre_test::task;
import instruct::practice;
import test::task;

int         BLOCK_NR;               // Which block 
int         TRIAL_NR;               // Which trial number
dur         RESPONSE_DURATION = 0ms; // ???

TestItem[]	TESTITEMS;              // Placeholder for the test items at hand.


Experiment experiment
{
    on_event:entry()
    {	
		control.button_box.open("/dev/ttyACM0");  
		show_test_windows();
    }
    
    on_event:message()
    {
        // On Ctrl+F4 jump unconditionally to the thank-you part.
        if (message_sender == control && message_arg == SYS_STOP)
        {
            control.mark_experiment_aborted();
            thankyou.enter();
        }
    }
	
    Part welcome
    {
        on_event:entry()
        {
            entry_page.set_text(WELCOME_TEXT);
            entry_page.action(this, 0s);
        }
    }
	
    Part first_instruction // instruction
	{
		on_event:entry()
        {
			println("==> Instructing <==");
			pause_page.set_text(INSTRUCTION_TEXT, true);
			pause_page.action_non_respond(this, DISABLE_PAUSE_BUTTONS_DURATION);
		}
	}

    // Just listen to type A and B stimuli.
    Part listen_phase
    {
        on_event:entry()
        {
            listening::action(this);
        }

        on_event:exit()
        {
            // Skip the instruction presented to a participant when he
            // fails the pre_test.
            press_button_phase.enter();
        }
    }

    // if a participant fails to meet the minimal performance on the pretest
    // we jump back to this part.
    Part blank_prior_to_2nd_pt_inst
    {
        on_event:entry()
        {
            blank_page.action_auto(this, 250ms, 250ms);
        }
    }
    
    // Instructions for when the pre_test criterium wasn't met.
    Part second_pretest_instruction
    {
        on_event:entry()
        {
            pause_page.set_text(SECOND_PRETEST_INSTRUCTION);
            pause_page.action(this, 250ms);
        }
    }

    // Press button A for an A type stimulus and button B for ...
    Part press_button_phase
    {
        on_event:entry()
        {
            button::action(this);
        }
    }

    Part
    {
        on_event:entry()
        {
            println("==> Instructing <==");
            pause_page.set_text(AFTER_PRACTICE_TEXT, true);
            pause_page.action_non_respond(this, DISABLE_PAUSE_BUTTONS_DURATION);
        }
    }
	

	Part
	{
		on_event:entry()
		{
			blank_page.action_auto(this, 500ms,500ms);
		}
	}

	Part
	{
		on_event:entry()
		{
			println("==> Pre-test <==");
			pre_test::task_call(this,2s);
		}
	}

    TransientPart DecideReDoPreTest
    {
        on_event:entry()
        {
            if (!pre_test::pretest.test_passed() ) {
                // run the pretest and button phase again.
                blank_prior_to_2nd_pt_inst.enter();
            }
            else {
                // save pretest TODO
            }
        }
    }
	
	Part
	{
		on_event:entry()
		{
			blank_page.action_auto(this, 500ms,500ms);
		}
	}
	
	Part
	{
		on_event:entry()
		{
			println("==> Instructing2 <==");
			pause_page.set_text(AFTER_PRETEST_TEXT, true);
			pause_page.action_non_respond(this, DISABLE_PAUSE_BUTTONS_DURATION);
		}
	}

	Part first_practice
	{
		on_event:entry()
        {
			if(CFG_GIVE_PRACTISE)
			{	
				println("==> Practicing <==");
				instruct::practice_call(this);
			} else signal(first_practice, CONTINUE);
        }
	}
	
	Part
	{
		on_event:entry()
		{
			blank_page.action_auto(this, 500ms,500ms);
		}
	}
	
	Part first_block 	// firstBlock
	{
		on_event:entry()
        {
			BLOCK_NR = BLOCK_NR + 1;
			
			println("=============================================");
			println("== Block 1                                 ==");
			println("=============================================");
			
			if(shuffle_test_items(seq_block1) != OK) { println("ERROR: something off with shuffle");	terminate;}
			
			test::task_call(this, seq_block1, RESPONSE_DURATION_BLOCK1); // args: caller object (this), testItem[..], block_nr, specific response duration
        }
	}
	
	Part 				// Pauze
    {
        on_event:entry()
        {
			pause_page.set_text(BLOCK_PAUZE_TEXT, true);
			pause_page.action_non_respond(this, DISABLE_PAUSE_BUTTONS_DURATION);
        }
    }
    
    Part second_block 	// Second Block
	{
		on_event:entry()
        {
			BLOCK_NR = BLOCK_NR + 1;
			
			println("=============================================");
			println("== Block 2                                ==");
			println("=============================================");
			
			if(shuffle_test_items(seq_block2) != OK) { println("ERROR: something off with shuffle");	terminate;}
			
			test::task_call(this, seq_block2, RESPONSE_DURATION_BLOCK2); // args: caller object (this), testItem[..], block_nr, specific response duration
        }
	}
	
	Part 				// Pauze
    {
        on_event:entry()
        {
			pause_page.set_text(BLOCK_SWITCH_TEXT, true);
			pause_page.action_non_respond(this, DISABLE_PAUSE_BUTTONS_DURATION);
        }
    }
    
    Part third_block 	// Third Block
	{
		on_event:entry()
        {
			BLOCK_NR = BLOCK_NR + 1;
			
			println("=============================================");
			println("== Block 3                                 ==");
			println("=============================================");
			
			if(shuffle_test_items(seq_block3) != OK) { println("ERROR: something off with shuffle");	terminate;}
			
			test::task_call(this, seq_block3, RESPONSE_DURATION_BLOCK3); // args: caller object (this), testItem[..], block_nr, specific response duration
        }
	}

	Part
	{
		on_event:entry()
		{
			blank_page.action_auto(this, 500ms,500ms);
		}
	}
    
    Part thankyou
    {
        on_event:entry()
        {			
			control.end_experiment();   // Check-in session.
			
			exit_page.set_text(THANK_YOU_TEXT);
			exit_page.action(this, 5s);
			control.button_box.close();  
        }
    }
}
